<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Asteroids in JavaScript</title>
    <style></style>
</head>

<body>
    <canvas id="game_container" width="800" height="700"></canvas>
    <script>
        // Create constants needed for the game
        const FPS = 30; // default standard framerate
        const SPACESHIP_SIZE = 30; // spaceship size in pixels
        const SPACESHIP_TURN_SPEED = 360; // spaceship turn speed in degrees
        const SPACESHIP_THRUST = 5; // spaceship thrust acceleration
        const SPACESHIP_FRICTION = 0.7; // spaceship friction coefficient of space (0 = no friction, 1 = lots of friction)
        const SPACESHIP_EXPLOSION_DURATION = 0.3; // Duration of the ship exploding in seconds
        const SPACESHIP_BLINK_DURATION = 0.1; // Duration of the ships blinks during invulnerability
        const SPACESHIP_INVULNERABILITY_DURATION = 3; // Duration of the ships invulnerability in seconds after respawning
        const ASTEROID_AMOUNT = 8; // Amount of asteroids in the game
        const ASTEROID_SPEED = 50; // Max speed at the start for each asteroid in pixels per second
        const ASTEROID_SIZE = 100;  // Size of each asteroid in pixels
        const ASTEROID_VERTICES = 10; // Roughly average number of vertices on each asteroid spawned
        const ASTEROID_RANDOMNESS = 0.4; // The randomness of each asteroids shape - higher value more interesting shapes
        const SHOW_CENTER_CIRCLE = true; // Toggle showing the red center circle for debugging purposes
        const SHOW_BOUNDING_BOXES = false; // Toggle showing the collision boxes for objects

        /** @type {HTMLCanvasElement} */
        var canvas = document.getElementById("game_container");
        var context = canvas.getContext("2d");

        // spaceship variable with all needed properties
        var spaceship = newSpaceShip();

        // asteroid variable stored in an array
        var asteroids = [];
        createAsteroids();

        // Event Handlers
        document.addEventListener("keydown", keyDownPressed);
        document.addEventListener("keyup", keyUpPressed);

        // Define the game loop and speed
        setInterval(update, 1000 / FPS);

        function createAsteroids() {

            // clear out any old asteroids
            asteroids = [];
            var x, y;

            for (var i = 0; i < ASTEROID_AMOUNT; i++) {
                // Add a bit of randomness to each asteroid postion spawning in
                do {
                    x = Math.floor(Math.random() * canvas.width);
                    y = Math.floor(Math.random() * canvas.height);
                } while (checkDistanceBetweenPoints(spaceship.x, spaceship.y, x, y) < ASTEROID_SIZE * 2 + spaceship.r);
                asteroids.push(newAsteroid(x, y));
            }
        }

        function checkDistanceBetweenPoints(x1, y1, x2, y2) {

            // Enforces a certain buffer zone around the spaceship to prevent asteroids spawning ontop
            return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        }


        function blowUpSpaceShip() {

            // Make a big explosion on the ship whenever a collision is detected
            spaceship.explosionTime = Math.ceil(SPACESHIP_EXPLOSION_DURATION * FPS);
        }

        function newAsteroid(x, y) {
            var asteroid = {
                x: x,
                y: y,
                xv: Math.random() * ASTEROID_SPEED / FPS * (Math.random() < 0.5 ? 1 : -1),
                yv: Math.random() * ASTEROID_SPEED / FPS * (Math.random() < 0.5 ? 1 : -1),
                r: ASTEROID_SIZE / 2,
                a: Math.random() * Math.PI * 2, // converted to radians
                randVertices: Math.floor(Math.random() * (ASTEROID_VERTICES + 1) + ASTEROID_VERTICES / 2),
                offset: []
            };

            // create the offset to cause random shapes
            for (var i = 0; i < asteroid.randVertices; i++) {

                asteroid.offset.push(Math.random() * ASTEROID_RANDOMNESS * 2 + 1 - ASTEROID_RANDOMNESS);
            }

            return asteroid;
        }

        function newSpaceShip() {

            return {
                x: canvas.width / 2,
                y: canvas.height / 2,
                r: SPACESHIP_SIZE / 2,
                a: 90 / 180 * Math.PI, // radian conversion
                rotation: 0,
                isThrusting: false,
                thrust: {
                    x: 0,
                    y: 0
                },
                explosionTime: 0,
                blinkTime: Math.ceil(SPACESHIP_BLINK_DURATION * FPS),
                blinkNumber: Math.ceil(SPACESHIP_INVULNERABILITY_DURATION / SPACESHIP_BLINK_DURATION)
            }
        }

        function keyDownPressed(/** @type {KeyBoardEvent} */ event) {

            switch (event.keyCode) {
                case 37: // left arrow key pressed - rotate left
                    spaceship.rotation = SPACESHIP_TURN_SPEED / 180 * Math.PI / FPS;
                    break;
                case 38: // up arrow key pressed - move ship forward
                    spaceship.isThrusting = true;
                    break;
                case 39: // right arrow key pressed - rotate right
                    spaceship.rotation = -SPACESHIP_TURN_SPEED / 180 * Math.PI / FPS;
                    break;
            }
        }

        function keyUpPressed(/** @type {KeyBoardEvent} */ event) {

            switch (event.keyCode) {
                case 37: // left arrow key not pressed anymore - stop rotating left
                    spaceship.rotation = 0;
                    break;
                case 38: // up arrow key not pressed anymore - stop ship moving forward
                    spaceship.isThrusting = false;
                case 39: // right arrow key not pressed anymore - stop rotating right
                    spaceship.rotation = 0;
                    break;
            }
        }

        // Update function that will run every frame
        function update() {

            var isExploding = spaceship.explosionTime > 0;
            var isBlinkOn = spaceship.blinkNumber % 2 == 0;

            // Background
            context.fillStyle = "black";
            context.fillRect(0, 0, canvas.width, canvas.height);

            // Spaceship thrusting
            if (spaceship.isThrusting) {
                spaceship.thrust.x += SPACESHIP_THRUST * Math.cos(spaceship.a) / FPS;
                spaceship.thrust.y -= SPACESHIP_THRUST * Math.sin(spaceship.a) / FPS;

                // add graphical thrusting to the spaceship
                if (!isExploding) {
                    context.fillStyle = "red";
                    context.strokeStyle = "yellow";
                    context.lineWidth = SPACESHIP_SIZE / 10;
                    context.beginPath();
                    context.moveTo( // starting at the rear left of the thruster
                        spaceship.x - spaceship.r * (2 / 3 * Math.cos(spaceship.a) + 0.5 * Math.sin(spaceship.a)),
                        spaceship.y + spaceship.r * (2 / 3 * Math.sin(spaceship.a) - 0.5 * Math.cos(spaceship.a))
                    );
                    context.lineTo( // rear centre behind the ship
                        spaceship.x - spaceship.r * 6 / 3 * Math.cos(spaceship.a),
                        spaceship.y + spaceship.r * 6 / 3 * Math.sin(spaceship.a)
                    );
                    context.lineTo( // draw line to bottom right corner
                        spaceship.x - spaceship.r * (2 / 3 * Math.cos(spaceship.a) - 0.5 * Math.sin(spaceship.a)),
                        spaceship.y + spaceship.r * (2 / 3 * Math.sin(spaceship.a) + 0.5 * Math.cos(spaceship.a))
                    );
                    // Use closePath to automatically close the triangle
                    context.closePath();
                    context.fill();
                    context.stroke();
                }

            } else {
                // Friction takes over since the ship is no longer thrusting
                spaceship.thrust.x -= SPACESHIP_FRICTION * spaceship.thrust.x / FPS;
                spaceship.thrust.y -= SPACESHIP_FRICTION * spaceship.thrust.y / FPS;
            }

            // Spaceship
            if (!isExploding) {
                if (isBlinkOn) {
                    context.strokeStyle = "white";
                    context.lineWidth = SPACESHIP_SIZE / 20;
                    context.beginPath();
                    context.moveTo( // starting at the top of the ship
                        spaceship.x + 4 / 3 * spaceship.r * Math.cos(spaceship.a),
                        spaceship.y - 4 / 3 * spaceship.r * Math.sin(spaceship.a)
                    );
                    context.lineTo( // draw line to bottom left corner
                        spaceship.x - spaceship.r * (2 / 3 * Math.cos(spaceship.a) + Math.sin(spaceship.a)),
                        spaceship.y + spaceship.r * (2 / 3 * Math.sin(spaceship.a) - Math.cos(spaceship.a))
                    );
                    context.lineTo( // draw line to bottom right corner
                        spaceship.x - spaceship.r * (2 / 3 * Math.cos(spaceship.a) - Math.sin(spaceship.a)),
                        spaceship.y + spaceship.r * (2 / 3 * Math.sin(spaceship.a) + Math.cos(spaceship.a))
                    );
                    // Use closePath to automatically close the triangle
                    context.closePath();
                    context.stroke();
                }
                    // Blink effect handling
                    if (spaceship.blinkNumber > 0) {

                        // decrease blink time
                        spaceship.blinkTime--;

                        // decrease the blink number
                        if (spaceship.blinkTime == 0) {

                            spaceship.blinkTime = Math.ceil(SPACESHIP_BLINK_DURATION * FPS);
                            spaceship.blinkNumber--;
                        }
                    }
            } else {

                // Draw an explosion in the spaceships place
                context.fillStyle = "darkred";
                context.beginPath();
                context.arc(spaceship.x, spaceship.y, spaceship.r * 1.7, 0, Math.PI * 2, false);
                context.fill();

                context.fillStyle = "red";
                context.beginPath();
                context.arc(spaceship.x, spaceship.y, spaceship.r * 1.4, 0, Math.PI * 2, false);
                context.fill();

                context.fillStyle = "orange";
                context.beginPath();
                context.arc(spaceship.x, spaceship.y, spaceship.r * 1.1, 0, Math.PI * 2, false);
                context.fill();

                context.fillStyle = "yellow";
                context.beginPath();
                context.arc(spaceship.x, spaceship.y, spaceship.r * 0.8, 0, Math.PI * 2, false);
                context.fill();

                context.fillStyle = "white";
                context.beginPath();
                context.arc(spaceship.x, spaceship.y, spaceship.r * 0.5, 0, Math.PI * 2, false);
                context.fill();
            }

            // Draw the collision boxes for the spaceship
            if (SHOW_BOUNDING_BOXES) {

                context.strokeStyle = "lime";
                context.beginPath();
                context.arc(spaceship.x, spaceship.y, spaceship.r, 0, Math.PI * 2, false);
                context.stroke();
            }

            // Draw the current asteroids
            var x, y, r, a, vertices, offset;

            for (var i = 0; i < asteroids.length; i++) {

                context.strokeStyle = "slategrey";
                context.lineWidth = SPACESHIP_SIZE / 20;

                // retrieve asteroid variables
                x = asteroids[i].x;
                y = asteroids[i].y;
                r = asteroids[i].r;
                a = asteroids[i].a;
                vertices = asteroids[i].randVertices;
                offset = asteroids[i].offset;

                // draw the path of the asteroids shape
                context.beginPath();
                context.moveTo(
                    x + r * offset[0] * Math.cos(a),
                    y + r * offset[0] * Math.sin(a),

                );

                // draw the full polygon
                for (var j = 0; j < vertices; j++) {
                    context.lineTo(
                        x + r * offset[j] * Math.cos(a + j * Math.PI * 2 / vertices),
                        y + r * offset[j] * Math.sin(a + j * Math.PI * 2 / vertices)
                    );
                }
                context.closePath();
                context.stroke();

                // Draw the collision boxes for asteroids
                if (SHOW_BOUNDING_BOXES) {

                    context.strokeStyle = "lime";
                    context.beginPath();
                    context.arc(x, y, r, 0, Math.PI * 2, false);
                    context.stroke();
                }

            }

            // Check for collisions
            if (!isExploding) {
                if (spaceship.blinkNumber == 0) {

                for (var i = 0; i < asteroids.length; i++) {

                    if (checkDistanceBetweenPoints(spaceship.x, spaceship.y, asteroids[i].x, asteroids[i].y) < spaceship.r + asteroids[i].r) {
                        blowUpSpaceShip();
                    }
                }
            }

                // Rotation
                spaceship.a += spaceship.rotation;

                // Movement
                spaceship.x += spaceship.thrust.x;
                spaceship.y += spaceship.thrust.y;

            } else {

                // Count down the explosion time until a new respawn happens
                spaceship.explosionTime--;

                if (spaceship.explosionTime == 0) {
                    spaceship = newSpaceShip();
                }
            }

            // Prevent ship flying off bounds
            if (spaceship.x < 0 - spaceship.r) {
                spaceship.x = canvas.width + spaceship.r;
            } else if (spaceship.x > canvas.width + spaceship.r) {
                spaceship.x = 0 - spaceship.r;
            }

            if (spaceship.y < 0 - spaceship.r) {
                spaceship.y = canvas.height + spaceship.r;
            } else if (spaceship.y > canvas.height + spaceship.r) {
                spaceship.y = 0 - spaceship.r;
            }

            // move the asteroids
            for (var i = 0; i < asteroids.length; i++) {
                asteroids[i].x += asteroids[i].xv;
                asteroids[i].y += asteroids[i].yv;

                // prevent the asteroid from disappearing going outside the screen
                if (asteroids[i].x < 0 - asteroids[i].r) {
                    asteroids[i].x = canvas.width + asteroids[i].r;
                } else if (asteroids[i].x > canvas.width + asteroids[i].r) {
                    asteroids[i].x = 0 - asteroids[i].r;
                }

                if (asteroids[i].y < 0 - asteroids[i].r) {
                    asteroids[i].y = canvas.height + asteroids[i].r;
                } else if (asteroids[i].y > canvas.height + asteroids[i].r) {
                    asteroids[i].y = 0 - asteroids[i].r;
                }
            }
            // Center of spaceship
            if (SHOW_CENTER_CIRCLE) {
                context.fillStyle = "red";
                context.fillRect(spaceship.x - 1, spaceship.y - 1, 2, 2);
            }
        }
    </script>
</body>

</html>